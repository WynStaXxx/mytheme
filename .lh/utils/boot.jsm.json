{
    "sourceFile": "utils/boot.jsm",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1649508267114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1649508267113,
            "name": "Commit-0",
            "content": "let EXPORTED_SYMBOLS = [];\n\nconsole.warn(\"Browser is executing custom scripts via autoconfig\");\nconst { Services } = ChromeUtils.import(\"resource://gre/modules/Services.jsm\");\n\nconst yPref = {\n  get: function (prefPath) {\n    const sPrefs = Services.prefs;\n    try {\n      switch (sPrefs.getPrefType(prefPath)) {\n        case 0:\n          return undefined;\n        case 32:\n          return sPrefs.getStringPref(prefPath);\n        case 64:\n          return sPrefs.getIntPref(prefPath);\n        case 128:\n          return sPrefs.getBoolPref(prefPath);\n      }\n    } catch (ex) {\n      return undefined;\n    }\n    return;\n  },\n  set: function (prefPath, value) {\n    const sPrefs = Services.prefs;\n    switch (typeof value) {\n      case \"string\":\n        return sPrefs.setCharPref(prefPath, value) || value;\n      case \"number\":\n        return sPrefs.setIntPref(prefPath, value) || value;\n      case \"boolean\":\n        return sPrefs.setBoolPref(prefPath, value) || value;\n    }\n    return;\n  },\n  addListener: (a, b) => {\n    let o = (q, w, e) => b(yPref.get(e), e);\n    Services.prefs.addObserver(a, o);\n    return { pref: a, observer: o };\n  },\n  removeListener: (a) => Services.prefs.removeObserver(a.pref, a.observer),\n};\n\nconst SHARED_GLOBAL = {};\nObject.defineProperty(SHARED_GLOBAL, \"widgetCallbacks\", { value: new Map() });\n\nfunction resolveChromeURL(str) {\n  const registry = Cc[\"@mozilla.org/chrome/chrome-registry;1\"].getService(\n    Ci.nsIChromeRegistry\n  );\n  try {\n    return registry.convertChromeURL(\n      Services.io.newURI(str.replace(/\\\\/g, \"/\"))\n    ).spec;\n  } catch (e) {\n    console.error(e);\n    return \"\";\n  }\n}\n// relative to \"chrome\" folder\nfunction resolveChromePath(str) {\n  let parts = resolveChromeURL(str).split(\"/\");\n  return parts.slice(parts.indexOf(\"chrome\") + 1, parts.length - 1).join(\"/\");\n}\n\nlet _uc = {\n  BROWSERCHROME: \"chrome://browser/content/browser.xhtml\",\n  PREF_ENABLED: \"userChromeJS.enabled\",\n  PREF_SCRIPTSDISABLED: \"userChromeJS.scriptsDisabled\",\n\n  SCRIPT_DIR: resolveChromePath(\"chrome://userscripts/content/\"),\n  RESOURCE_DIR: resolveChromePath(\"chrome://userchrome/content/\"),\n  BASE_FILEURI: Services.io\n    .getProtocolHandler(\"file\")\n    .QueryInterface(Ci.nsIFileProtocolHandler)\n    .getURLSpecFromDir(Services.dirsvc.get(\"UChrm\", Ci.nsIFile)),\n\n  SESSION_RESTORED: false,\n\n  get chromeDir() {\n    return Services.dirsvc.get(\"UChrm\", Ci.nsIFile);\n  },\n\n  getDirEntry: function (filename, isLoader = false) {\n    filename = filename.replace(\"\\\\\", \"/\");\n    let pathParts = (\n      (filename.startsWith(\"..\")\n        ? \"\"\n        : isLoader\n        ? _uc.SCRIPT_DIR\n        : _uc.RESOURCE_DIR) +\n      \"/\" +\n      filename\n    )\n      .split(\"/\")\n      .filter((a) => !!a && a != \"..\");\n    let entry = _uc.chromeDir;\n\n    for (let part of pathParts) {\n      entry.append(part);\n    }\n    if (!entry.exists()) {\n      return null;\n    }\n    if (entry.isDirectory()) {\n      return entry.directoryEntries.QueryInterface(Ci.nsISimpleEnumerator);\n    } else if (entry.isFile()) {\n      return entry;\n    } else {\n      return null;\n    }\n  },\n\n  updateStyleSheet: function (name, type) {\n    if (type) {\n      let sss = Cc[\"@mozilla.org/content/style-sheet-service;1\"].getService(\n        Ci.nsIStyleSheetService\n      );\n      try {\n        let uri = Services.io.newURI(`chrome://userchrome/content/${name}`);\n        switch (type) {\n          case \"agent\":\n            sss.unregisterSheet(uri, sss.AGENT_SHEET);\n            sss.loadAndRegisterSheet(uri, sss.AGENT_SHEET);\n            return true;\n          case \"author\":\n            sss.unregisterSheet(uri, sss.AUTHOR_SHEET);\n            sss.loadAndRegisterSheet(uri, sss.AUTHOR_SHEET);\n            return true;\n          default:\n            return false;\n        }\n      } catch (e) {\n        console.error(e);\n        return false;\n      }\n    }\n    let entry = _uc.utils.getFSEntry(name);\n    if (!(entry && entry.isFile())) {\n      return false;\n    }\n    let recentWindow = Services.wm.getMostRecentBrowserWindow();\n    if (!recentWindow) {\n      return false;\n    }\n    function recurseImports(sheet, all) {\n      let z = 0;\n      let rule = sheet.cssRules[0];\n      // loop through import rules and check that the \"all\"\n      // doesn't already contain the same object\n      while (rule instanceof CSSImportRule && !all.includes(rule.styleSheet)) {\n        all.push(rule.styleSheet);\n        recurseImports(rule.styleSheet, all);\n        rule = sheet.cssRules[++z];\n      }\n      return all;\n    }\n\n    let sheets = recentWindow.InspectorUtils.getAllStyleSheets(\n      recentWindow.document,\n      false\n    );\n\n    sheets = sheets.flatMap((x) => recurseImports(x, [x]));\n\n    // If a sheet is imported multiple times, then there will be\n    // duplicates, because style system does create an object for\n    // each instace but that's OK since sheets.find below will\n    // only find the first instance and reload that which is\n    // \"probably\" fine.\n    let entryFilePath = `file:///${entry.path.replaceAll(\"\\\\\", \"/\")}`;\n\n    let target = sheets.find((sheet) => sheet.href === entryFilePath);\n    if (target) {\n      recentWindow.InspectorUtils.parseStyleSheet(\n        target,\n        _uc.utils.readFile(entry)\n      );\n      return true;\n    }\n    return false;\n  },\n\n  getScripts: function () {\n    this.scripts = {};\n    if (!yPref.get(_uc.PREF_ENABLED) || !/^[\\w_]*$/.test(_uc.SCRIPT_DIR)) {\n      console.log(\n        \"Scripts are disabled or the given script directory name is invalid\"\n      );\n      return;\n    }\n    let files = _uc.getDirEntry(\"\", true);\n    while (files.hasMoreElements()) {\n      let file = files.getNext().QueryInterface(Ci.nsIFile);\n      if (/\\.uc\\.js$/i.test(file.leafName)) {\n        let script = _uc.getScriptData(file);\n        if (script.inbackground && script.isEnabled) {\n          try {\n            Cu.import(`chrome://userscripts/content/${script.filename}`);\n          } catch (e) {\n            console.error(e);\n          }\n        }\n      }\n    }\n  },\n\n  getScriptData: function (aFile) {\n    let header = (_uc.utils\n      .readFile(aFile, true)\n      .match(\n        /^\\/\\/ ==UserScript==\\s*\\n(?:.*\\n)*?\\/\\/ ==\\/UserScript==\\s*\\n/m\n      ) || [\"\"])[0];\n    let match,\n      rex = {\n        include: [],\n        exclude: [],\n      };\n    let findNextRe = /^\\/\\/ @(include|exclude)\\s+(.+)\\s*$/gm;\n    while ((match = findNextRe.exec(header))) {\n      rex[match[1]].push(\n        match[2].replace(/^main$/i, _uc.BROWSERCHROME).replace(/\\*/g, \".*?\")\n      );\n    }\n    if (!rex.include.length) {\n      rex.include.push(_uc.BROWSERCHROME);\n    }\n    let exclude = rex.exclude.length ? `(?!${rex.exclude.join(\"$|\")}$)` : \"\";\n    let def = [\"\", \"\"];\n    let author = (header.match(/\\/\\/ @author\\s+(.+)\\s*$/im) || def)[1];\n    let filename = aFile.leafName || \"\";\n\n    return (this.scripts[filename] = {\n      filename: filename,\n      name: (header.match(/\\/\\/ @name\\s+(.+)\\s*$/im) || def)[1],\n      charset: (header.match(/\\/\\/ @charset\\s+(.+)\\s*$/im) || def)[1],\n      description: (header.match(/\\/\\/ @description\\s+(.+)\\s*$/im) || def)[1],\n      version: (header.match(/\\/\\/ @version\\s+(.+)\\s*$/im) || def)[1],\n      author: (header.match(/\\/\\/ @author\\s+(.+)\\s*$/im) || def)[1],\n      regex: new RegExp(`^${exclude}(${rex.include.join(\"|\") || \".*\"})$`, \"i\"),\n      id: (header.match(/\\/\\/ @id\\s+(.+)\\s*$/im) || [\n        \"\",\n        filename.split(\".uc.js\")[0] + \"@\" + (author || \"userChromeJS\"),\n      ])[1],\n      homepageURL: (header.match(/\\/\\/ @homepageURL\\s+(.+)\\s*$/im) || def)[1],\n      downloadURL: (header.match(/\\/\\/ @downloadURL\\s+(.+)\\s*$/im) || def)[1],\n      updateURL: (header.match(/\\/\\/ @updateURL\\s+(.+)\\s*$/im) || def)[1],\n      optionsURL: (header.match(/\\/\\/ @optionsURL\\s+(.+)\\s*$/im) || def)[1],\n      startup: (header.match(/\\/\\/ @startup\\s+(.+)\\s*$/im) || def)[1],\n      onlyonce: /\\/\\/ @onlyonce\\b/.test(header),\n      inbackground: /\\/\\/ @backgroundmodule\\b/.test(header),\n      ignoreCache: /\\/\\/ @ignorecache\\b/.test(header),\n      isRunning: false,\n      get isEnabled() {\n        return (\n          (yPref.get(_uc.PREF_SCRIPTSDISABLED) || \"\")\n            .split(\",\")\n            .indexOf(this.filename) === -1\n        );\n      },\n    });\n  },\n\n  maybeRunStartUp: (script, win) => {\n    if (\n      script.startup &&\n      /^\\w*$/.test(script.startup) &&\n      SHARED_GLOBAL[script.startup] &&\n      typeof SHARED_GLOBAL[script.startup]._startup === \"function\"\n    ) {\n      SHARED_GLOBAL[script.startup]._startup(win);\n    }\n  },\n\n  loadScript: function (script, win) {\n    if (\n      script.inbackground ||\n      !script.regex.test(win.location.href) ||\n      !script.isEnabled\n    ) {\n      return;\n    }\n    try {\n      if (script.onlyonce && script.isRunning) {\n        _uc.maybeRunStartUp(script, win);\n        return;\n      }\n\n      Services.scriptloader.loadSubScriptWithOptions(\n        `chrome://userscripts/content/${script.filename}`,\n        {\n          target: win,\n          ignoreCache: script.ignoreCache,\n        }\n      );\n\n      script.isRunning = true;\n      _uc.maybeRunStartUp(script, win);\n    } catch (ex) {\n      console.error(ex);\n    }\n    return;\n  },\n\n  // things to be exported for use by userscripts\n  utils: {\n    get sharedGlobal() {\n      return SHARED_GLOBAL;\n    },\n\n    createElement: function (doc, tag, props, isHTML = false) {\n      let el = isHTML ? doc.createElement(tag) : doc.createXULElement(tag);\n      for (let prop in props) {\n        el.setAttribute(prop, props[prop]);\n      }\n      return el;\n    },\n\n    createWidget(desc) {\n      if (!desc || !desc.id) {\n        console.error(\"custom widget description is missing 'id' property\");\n        return null;\n      }\n      if (![\"toolbaritem\", \"toolbarbutton\"].includes(desc.type)) {\n        console.error(\"custom widget has unsupported type: \" + desc.type);\n        return null;\n      }\n      const CUI = Services.wm.getMostRecentBrowserWindow().CustomizableUI;\n      let newWidget = CUI.getWidget(desc.id);\n\n      if (newWidget && newWidget.hasOwnProperty(\"source\")) {\n        // very likely means that the widget with this id already exists\n        // There isn't a very reliable way to 'really' check if it exists or not\n        return newWidget;\n      }\n      // This is pretty ugly but makes onBuild much cleaner.\n      let itemStyle = \"\";\n      if (desc.image) {\n        if (desc.type === \"toolbarbutton\") {\n          itemStyle += \"list-style-image:\";\n        } else {\n          itemStyle += \"background: transparent center no-repeat \";\n        }\n        itemStyle += `url(chrome://userChrome/content/${desc.image});`;\n        itemStyle += desc.style || \"\";\n      }\n      SHARED_GLOBAL.widgetCallbacks.set(desc.id, desc.callback);\n\n      return CUI.createWidget({\n        id: desc.id,\n        type: \"custom\",\n        onBuild: function (aDocument) {\n          let toolbaritem = aDocument.createXULElement(desc.type);\n          let props = {\n            id: desc.id,\n            class: `toolbarbutton-1 chromeclass-toolbar-additional ${\n              desc.class ? desc.class : \"\"\n            }`,\n            overflows: !!desc.overflows,\n            label: desc.label || desc.id,\n            tooltiptext: desc.tooltip || desc.id,\n            style: itemStyle,\n            onclick: `${\n              desc.allEvents ? \"\" : \"event.button===0 && \"\n            }_ucUtils.sharedGlobal.widgetCallbacks.get(this.id)(event,window)`,\n          };\n          for (let p in props) {\n            toolbaritem.setAttribute(p, props[p]);\n          }\n          return toolbaritem;\n        },\n      });\n    },\n\n    readFile: function (aFile, metaOnly = false) {\n      let stream = Cc[\n        \"@mozilla.org/network/file-input-stream;1\"\n      ].createInstance(Ci.nsIFileInputStream);\n      let cvstream = Cc[\n        \"@mozilla.org/intl/converter-input-stream;1\"\n      ].createInstance(Ci.nsIConverterInputStream);\n      try {\n        stream.init(aFile, 0x01, 0, 0);\n        cvstream.init(\n          stream,\n          \"UTF-8\",\n          1024,\n          Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER\n        );\n      } catch (e) {\n        console.error(e);\n        return null;\n      }\n      let content = \"\",\n        data = {};\n      while (cvstream.readString(4096, data)) {\n        content += data.value;\n        if (metaOnly && content.indexOf(\"// ==/UserScript==\") > 0) {\n          break;\n        }\n      }\n      cvstream.close();\n      stream.close();\n      return content.replace(/\\r\\n?/g, \"\\n\");\n    },\n\n    createFileURI: (fileName = \"\") => {\n      fileName = String(fileName);\n      let u = resolveChromeURL(`chrome://userchrome/content/${fileName}`);\n      return fileName ? u : u.substr(0, u.lastIndexOf(\"/\") + 1);\n    },\n\n    get chromeDir() {\n      return {\n        get files() {\n          return _uc.chromeDir.directoryEntries.QueryInterface(\n            Ci.nsISimpleEnumerator\n          );\n        },\n        uri: _uc.BASE_FILEURI,\n      };\n    },\n\n    getFSEntry: (fileName) => _uc.getDirEntry(fileName),\n\n    getScriptData: () => {\n      let scripts = [];\n      for (let script in _uc.scripts) {\n        let data = {};\n        let o = _uc.scripts[script];\n        for (let p in o) {\n          if (p != \"isEnabled\") {\n            data[p] = o[p];\n          }\n        }\n        scripts.push(data);\n      }\n      return scripts;\n    },\n\n    get windows() {\n      return {\n        get: function (onlyBrowsers = true) {\n          let windows = Services.wm.getEnumerator(\n            onlyBrowsers ? \"navigator:browser\" : null\n          );\n          let wins = [];\n          while (windows.hasMoreElements()) {\n            wins.push(windows.getNext());\n          }\n          return wins;\n        },\n        forEach: function (fun, onlyBrowsers = true) {\n          let wins = this.get(onlyBrowsers);\n          wins.forEach((w) => fun(w.document, w));\n        },\n      };\n    },\n\n    toggleScript: function (el) {\n      let isElement = !!el.tagName;\n      if (!isElement && typeof el != \"string\") {\n        return;\n      }\n      let script = _uc.scripts[isElement ? el.getAttribute(\"filename\") : el];\n      if (!script) {\n        console.log(\"no script to toggle\");\n        return;\n      }\n      if (script.isEnabled) {\n        yPref.set(\n          _uc.PREF_SCRIPTSDISABLED,\n          `${script.filename},${yPref.get(_uc.PREF_SCRIPTSDISABLED)}`\n        );\n      } else {\n        yPref.set(\n          _uc.PREF_SCRIPTSDISABLED,\n          yPref\n            .get(_uc.PREF_SCRIPTSDISABLED)\n            .replace(\n              new RegExp(`^${script.filename},?|,${script.filename}`),\n              \"\"\n            )\n        );\n      }\n      Services.appinfo.invalidateCachesOnRestart();\n    },\n\n    updateStyleSheet: function (name = \"../userChrome.css\", type) {\n      return _uc.updateStyleSheet(name, type);\n    },\n\n    updateMenuStatus: function (menu) {\n      if (!menu) {\n        return;\n      }\n      let disabledScripts = yPref.get(_uc.PREF_SCRIPTSDISABLED).split(\",\");\n      for (let item of menu.children) {\n        if (disabledScripts.includes(item.getAttribute(\"filename\"))) {\n          item.removeAttribute(\"checked\");\n        } else {\n          item.setAttribute(\"checked\", \"true\");\n        }\n      }\n    },\n\n    startupFinished: function () {\n      return new Promise((resolve) => {\n        if (_uc.SESSION_RESTORED) {\n          resolve();\n        } else {\n          let observer = (subject, topic, data) => {\n            Services.obs.removeObserver(\n              observer,\n              \"sessionstore-windows-restored\"\n            );\n            resolve();\n          };\n          Services.obs.addObserver(observer, \"sessionstore-windows-restored\");\n        }\n      });\n    },\n\n    windowIsReady: function (win) {\n      if (win && win.isChromeWindow) {\n        return new Promise((resolve) => {\n          if (win.gBrowserInit.delayedStartupFinished) {\n            resolve();\n          } else {\n            let observer = (subject, topic, data) => {\n              if (subject === win) {\n                Services.obs.removeObserver(\n                  observer,\n                  \"browser-delayed-startup-finished\"\n                );\n                resolve();\n              }\n            };\n            Services.obs.addObserver(\n              observer,\n              \"browser-delayed-startup-finished\"\n            );\n          }\n        });\n      } else {\n        return Promise.reject(new Error(\"reference is not a window\"));\n      }\n    },\n\n    registerHotkey: function (desc, func) {\n      const validMods = [\"accel\", \"alt\", \"ctrl\", \"meta\", \"shift\"];\n      const validKey = (k) =>\n        /^[\\w-]$/.test(k) ? 1 : /^F(?:1[0,2]|[1-9])$/.test(k) ? 2 : 0;\n      const NOK = (a) => typeof a != \"string\";\n      const eToO = (e) => ({\n        metaKey: e.metaKey,\n        ctrlKey: e.ctrlKey,\n        altKey: e.altKey,\n        shiftKey: e.shiftKey,\n        key: e.srcElement.getAttribute(\"key\"),\n        id: e.srcElement.getAttribute(\"id\"),\n      });\n\n      if (NOK(desc.id) || NOK(desc.key) || NOK(desc.modifiers)) {\n        return false;\n      }\n\n      try {\n        let mods = desc.modifiers\n          .toLowerCase()\n          .split(\" \")\n          .filter((a) => validMods.includes(a));\n        let key = validKey(desc.key);\n        if (!key || (mods.length === 0 && key === 1)) {\n          return false;\n        }\n\n        _uc.utils.windows.forEach((doc, win) => {\n          if (doc.getElementById(desc.id)) {\n            return;\n          }\n          let details = {\n            id: desc.id,\n            modifiers: mods.join(\",\").replace(\"ctrl\", \"accel\"),\n            oncommand: \"//\",\n          };\n          if (key === 1) {\n            details.key = desc.key.toUpperCase();\n          } else {\n            details.keycode = `VK_${desc.key}`;\n          }\n\n          let el = _uc.utils.createElement(doc, \"key\", details);\n\n          el.addEventListener(\"command\", (ev) => {\n            func(ev.target.ownerGlobal, eToO(ev));\n          });\n          let keyset =\n            doc.getElementById(\"mainKeyset\") ||\n            doc.body.appendChild(\n              _uc.utils.createElement(doc, \"keyset\", { id: \"ucKeys\" })\n            );\n          keyset.insertBefore(el, keyset.firstChild);\n        });\n      } catch (e) {\n        console.error(e);\n        return false;\n      }\n      return true;\n    },\n    loadURI: function (win, desc) {\n      if (\n        !win ||\n        !desc ||\n        !desc.url ||\n        typeof desc.url !== \"string\" ||\n        ![\"tab\", \"tabshifted\", \"window\", \"current\"].includes(desc.where)\n      ) {\n        return false;\n      }\n      const isJsURI = desc.url.slice(0, 11) === \"javascript:\";\n      try {\n        win.openTrustedLinkIn(desc.url, desc.where, {\n          allowPopups: isJsURI,\n          inBackground: false,\n          allowInheritPrincipal: false,\n          private: !!desc.private,\n          userContextId: desc.url.startsWith(\"http\")\n            ? desc.userContextId\n            : null,\n        });\n      } catch (e) {\n        console.error(e);\n        return false;\n      }\n      return true;\n    },\n    get prefs() {\n      return yPref;\n    },\n\n    showNotification: async function (description) {\n      await _uc.utils.startupFinished();\n      let window = description.window;\n      if (!(window && window.isChromeWindow)) {\n        window = Services.wm.getMostRecentBrowserWindow();\n      }\n      let aNotificationBox = window.gNotificationBox;\n      if (description.tab) {\n        let aBrowser = description.tab.linkedBrowser;\n        if (!aBrowser) {\n          return;\n        }\n        aNotificationBox = window.gBrowser.getNotificationBox(aBrowser);\n      }\n      if (!aNotificationBox) {\n        return;\n      }\n      let type = description.type || \"default\";\n      let priority = aNotificationBox.PRIORITY_INFO_HIGH;\n      switch (description.priority) {\n        case \"system\":\n          priority = aNotificationBox.PRIORITY_SYSTEM;\n          break;\n        case \"critical\":\n          priority = aNotificationBox.PRIORITY_CRITICAL_HIGH;\n          break;\n        case \"warning\":\n          priority = aNotificationBox.PRIORITY_WARNING_HIGH;\n          break;\n      }\n      aNotificationBox.appendNotification(\n        type,\n        {\n          label: description.label || \"ucUtils message\",\n          image: \"chrome://browser/skin/notification-icons/popup.svg\",\n          priority: priority,\n          eventCallback:\n            typeof description.callback === \"function\"\n              ? description.callback\n              : null,\n        },\n        description.buttons\n      );\n    },\n\n    restart: function (clearCache) {\n      clearCache && Services.appinfo.invalidateCachesOnRestart();\n      let cancelQuit = Cc[\"@mozilla.org/supports-PRBool;1\"].createInstance(\n        Ci.nsISupportsPRBool\n      );\n      Services.obs.notifyObservers(\n        cancelQuit,\n        \"quit-application-requested\",\n        \"restart\"\n      );\n      Services.startup.quit(\n        Services.startup.eAttemptQuit | Services.startup.eRestart\n      );\n    },\n  },\n};\n\nObject.freeze(_uc.utils);\n_uc.utils.startupFinished().then(() => {\n  _uc.SESSION_RESTORED = true;\n});\n\nif (yPref.get(_uc.PREF_ENABLED) === undefined) {\n  yPref.set(_uc.PREF_ENABLED, true);\n}\n\nif (yPref.get(_uc.PREF_SCRIPTSDISABLED) === undefined) {\n  yPref.set(_uc.PREF_SCRIPTSDISABLED, \"\");\n}\n\nfunction UserChrome_js() {\n  _uc.getScripts();\n  Services.obs.addObserver(this, \"domwindowopened\", false);\n}\n\nUserChrome_js.prototype = {\n  observe: function (aSubject, aTopic, aData) {\n    aSubject.addEventListener(\"DOMContentLoaded\", this, true);\n  },\n\n  handleEvent: function (aEvent) {\n    let document = aEvent.originalTarget;\n    let window = document.defaultView;\n    let regex =\n      /^chrome:(?!\\/\\/global\\/content\\/(commonDialog|alerts\\/alert)\\.xhtml)|about:(?!blank)/i;\n    // Don't inject scripts to modal prompt windows or notifications\n    if (regex.test(window.location.href)) {\n      Object.defineProperty(window, \"_ucUtils\", { get: () => _uc.utils });\n      document.allowUnsafeHTML = false; // https://bugzilla.mozilla.org/show_bug.cgi?id=1432966\n      if (window._gBrowser) {\n        // bug 1443849\n        window.gBrowser = window._gBrowser;\n      }\n      let isWindow = window.isChromeWindow;\n\n      /* Add a way to toggle scripts in tools menu */\n      let menu, popup, item;\n      let ce = _uc.utils.createElement;\n      if (isWindow) {\n        menu = document.querySelector(\"#menu_openDownloads\");\n        if (menu) {\n          try {\n            popup = ce(document, \"menupopup\", {\n              id: \"menuUserScriptsPopup\",\n              onpopupshown: `_ucUtils.updateMenuStatus(this)`,\n            });\n            item = ce(document, \"menu\", {\n              id: \"userScriptsMenu\",\n              label: \"userScripts\",\n            });\n          } catch (e) {\n            isWindow = false;\n          }\n        } else {\n          isWindow = false;\n        }\n      }\n      if (yPref.get(_uc.PREF_ENABLED)) {\n        Object.values(_uc.scripts).forEach((script) => {\n          _uc.loadScript(script, window);\n          if (isWindow) {\n            popup.appendChild(\n              ce(document, \"menuitem\", {\n                type: \"checkbox\",\n                label: script.name || script.filename,\n                filename: script.filename,\n                checked: \"true\",\n                oncommand: `_ucUtils.toggleScript(this)`,\n              })\n            );\n          }\n        });\n      }\n      if (isWindow) {\n        popup.appendChild(ce(document, \"menuseparator\", {}));\n        popup.appendChild(\n          ce(document, \"menuitem\", {\n            label: \"Restart now!\",\n            oncommand: \"_ucUtils.restart(true)\",\n            tooltiptext: \"Toggling scripts requires a restart\",\n          })\n        );\n        item.appendChild(popup);\n        menu.parentNode.insertBefore(item, menu);\n      }\n    }\n  },\n};\n\n!Services.appinfo.inSafeMode && new UserChrome_js();\n"
        }
    ]
}